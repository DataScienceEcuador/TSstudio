<!-- Generated by pkgdown: do not edit by hand -->
<!DOCTYPE html>
<html lang="en">
  <head>
  <meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<title>Train, Test, Evaluate, and Forecast Multiple Time Series Forecasting Models — train_model • TSstudio</title>

<!-- jquery -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js" integrity="sha256-FgpCb/KJQlLNfOu91ta32o/NMZxltwRo8QtmkMRdAu8=" crossorigin="anonymous"></script>
<!-- Bootstrap -->

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha256-916EbMg70RQy9LHiGkXzG8hSg9EdNy97GazNG/aiY1w=" crossorigin="anonymous" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha256-U5ZEeKfGNOja007MMD3YBI0A3OSZOQbeG6z2f2Y0hu8=" crossorigin="anonymous"></script>

<!-- Font Awesome icons -->
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" integrity="sha256-eZrrJcwDc/3uDhsdt61sL2oOBY362qM3lon1gyExkL0=" crossorigin="anonymous" />

<!-- clipboard.js -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.4/clipboard.min.js" integrity="sha256-FiZwavyI2V6+EXO1U+xzLG3IKldpiTFf3153ea9zikQ=" crossorigin="anonymous"></script>

<!-- sticky kit -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/sticky-kit/1.1.3/sticky-kit.min.js" integrity="sha256-c4Rlo1ZozqTPE2RLuvbusY3+SU1pQaJC0TjuhygMipw=" crossorigin="anonymous"></script>

<!-- pkgdown -->
<link href="../pkgdown.css" rel="stylesheet">
<script src="../pkgdown.js"></script>



<meta property="og:title" content="Train, Test, Evaluate, and Forecast Multiple Time Series Forecasting Models — train_model" />

<meta property="og:description" content="Method for train test and compare multiple time series models using either one partition (i.e., sample out) 
or multipe partitions (backtesting)" />
<meta name="twitter:card" content="summary" />



<!-- mathjax -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js" integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/config/TeX-AMS-MML_HTMLorMML.js" integrity="sha256-84DKXVJXs0/F8OTMzX4UR909+jtl4G7SPypPavF+GfA=" crossorigin="anonymous"></script>

<!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]-->


  </head>

  <body>
    <div class="container template-reference-topic">
      <header>
      <div class="navbar navbar-default navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <span class="navbar-brand">
        <a class="navbar-link" href="../index.html">TSstudio</a>
        <span class="version label label-default" data-toggle="tooltip" data-placement="bottom" title="Released version">0.1.5</span>
      </span>
    </div>

    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        <li>
  <a href="../index.html">
    <span class="fa fa-home fa-lg"></span>
     
  </a>
</li>
<li>
  <a href="../reference/index.html">Reference</a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    Articles
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li>
      <a href="../articles/Plotting_Time_Series.html">Plotting Time Series Data</a>
    </li>
  </ul>
</li>
<li>
  <a href="../news/index.html">Changelog</a>
</li>
      </ul>
      
      <ul class="nav navbar-nav navbar-right">
        <li>
  <a href="https://github.com/RamiKrispin/TSstudio">
    <span class="fa fa-github fa-lg"></span>
     
  </a>
</li>
      </ul>
      
    </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

      
      </header>

<div class="row">
  <div class="col-md-9 contents">
    <div class="page-header">
    <h1>Train, Test, Evaluate, and Forecast Multiple Time Series Forecasting Models</h1>
    <small class="dont-index">Source: <a href='https://github.com/RamiKrispin/TSstudio/blob/master/R/train_functions.R'><code>R/train_functions.R</code></a></small>
    <div class="hidden name"><code>train_model.Rd</code></div>
    </div>

    <div class="ref-description">
    
    <p>Method for train test and compare multiple time series models using either one partition (i.e., sample out) 
or multipe partitions (backtesting)</p>
    
    </div>

    <pre class="usage"><span class='fu'>train_model</span>(<span class='no'>input</span>, <span class='no'>methods</span>, <span class='no'>train_method</span>, <span class='no'>horizon</span>, <span class='kw'>error</span> <span class='kw'>=</span> <span class='st'>"MAPE"</span>,
  <span class='kw'>xreg</span> <span class='kw'>=</span> <span class='kw'>NULL</span>)</pre>
    
    <h2 class="hasAnchor" id="arguments"><a class="anchor" href="#arguments"></a>Arguments</h2>
    <table class="ref-arguments">
    <colgroup><col class="name" /><col class="desc" /></colgroup>
    <tr>
      <th>input</th>
      <td><p>A univariate time series object (ts class)</p></td>
    </tr>
    <tr>
      <th>methods</th>
      <td><p>A list, defines the models to use for training and forecasting the series. 
The list must include a sub list with the model type, and the model's arguments (when applicable) and notes about the model. 
The sub-list name will be used as the model ID. Possible models:</p>
<p><code><a href='https://www.rdocumentation.org/packages/stats/topics/arima'>arima</a></code> - model from the stats package</p>
<p><code><a href='https://www.rdocumentation.org/packages/forecast/topics/auto.arima'>auto.arima</a></code> - model from the forecast package</p>
<p><code><a href='https://www.rdocumentation.org/packages/forecast/topics/ets'>ets</a></code> - model from the forecast package</p>
<p><code><a href='https://www.rdocumentation.org/packages/stats/topics/HoltWinters'>HoltWinters</a></code> - model from the stats package</p>
<p><code><a href='https://www.rdocumentation.org/packages/forecast/topics/nnetar'>nnetar</a></code> - model from the forecast package</p>
<p><code><a href='https://www.rdocumentation.org/packages/forecast/topics/tslm'>tslm</a></code> - model from the forecast package (note that the 'tslm' model must have the formula argument in the 'method_arg' argument)</p></td>
    </tr>
    <tr>
      <th>train_method</th>
      <td><p>A list, defines the backtesting parameters:</p>
<p>partitions - an integer, set the number of training and testing partitions to be used in the backtesting process, 
where when partition is set to 1 it is a simple holdout training approach</p> 
<p>space - an integer, defines the length of the backtesting window expansion</p> 
<p>sample.in - an integer, optional, defines the length of the training partitions, and therefore the backtesting window structure. 
By default, it set to NULL and therefore, the backtesting using expending window. 
Otherwise, when the sample.in defined, the window structure is sliding</p> 
<p>sample.in - an integer, optional, defines the length of the training partitions, and therefore the type of the backtesting window. 
By default, is set to NULL, which implay that the backtesting is using an expending window. Otherwise, when defining the size of the training partition, th
defines the train approach, either using a single testing partition (sample out) 
or use multiple testing partitions (backtesting). The list should include the training method argument, (please see 'details' for the structure of the argument)</p></td>
    </tr>
    <tr>
      <th>horizon</th>
      <td><p>An integer, defines the forecast horizon</p></td>
    </tr>
    <tr>
      <th>error</th>
      <td><p>A character, defines the error metrics to be used to sort the models leaderboard. Possible metric - "MAPE" or "RMSE"</p></td>
    </tr>
    <tr>
      <th>xreg</th>
      <td><p>Optional, a list with two vectors (e.g., data.frame or matrix) of external regressors, 
one vector corresponding to the input series and second to the forecast itself 
(e.g., must have the same length as the input and forecast horizon, respectively)</p></td>
    </tr>
    </table>
    

    <h2 class="hasAnchor" id="examples"><a class="anchor" href="#examples"></a>Examples</h2>
    <pre class="examples"><div class='input'>
<span class='co'># Defining the models and their arguments</span>
<span class='no'>methods</span> <span class='kw'>&lt;-</span> <span class='fu'><a href='https://www.rdocumentation.org/packages/base/topics/list'>list</a></span>(<span class='kw'>ets1</span> <span class='kw'>=</span> <span class='fu'><a href='https://www.rdocumentation.org/packages/base/topics/list'>list</a></span>(<span class='kw'>method</span> <span class='kw'>=</span> <span class='st'>"ets"</span>,
                            <span class='kw'>method_arg</span> <span class='kw'>=</span> <span class='fu'><a href='https://www.rdocumentation.org/packages/base/topics/list'>list</a></span>(<span class='kw'>opt.crit</span> <span class='kw'>=</span> <span class='st'>"lik"</span>),
                            <span class='kw'>notes</span> <span class='kw'>=</span> <span class='st'>"ETS model with opt.crit = lik"</span>),
                <span class='kw'>ets2</span> <span class='kw'>=</span> <span class='fu'><a href='https://www.rdocumentation.org/packages/base/topics/list'>list</a></span>(<span class='kw'>method</span> <span class='kw'>=</span> <span class='st'>"ets"</span>,
                            <span class='kw'>method_arg</span> <span class='kw'>=</span> <span class='fu'><a href='https://www.rdocumentation.org/packages/base/topics/list'>list</a></span>(<span class='kw'>opt.crit</span> <span class='kw'>=</span> <span class='st'>"amse"</span>),
                            <span class='kw'>notes</span> <span class='kw'>=</span> <span class='st'>"ETS model with opt.crit = amse"</span>),
                <span class='kw'>arima1</span> <span class='kw'>=</span> <span class='fu'><a href='https://www.rdocumentation.org/packages/base/topics/list'>list</a></span>(<span class='kw'>method</span> <span class='kw'>=</span> <span class='st'>"arima"</span>,
                              <span class='kw'>method_arg</span> <span class='kw'>=</span> <span class='fu'><a href='https://www.rdocumentation.org/packages/base/topics/list'>list</a></span>(<span class='kw'>order</span> <span class='kw'>=</span> <span class='fu'><a href='https://www.rdocumentation.org/packages/base/topics/c'>c</a></span>(<span class='fl'>2</span>,<span class='fl'>1</span>,<span class='fl'>1</span>),
                                                <span class='kw'>seasonal</span> <span class='kw'>=</span> <span class='fu'><a href='https://www.rdocumentation.org/packages/base/topics/list'>list</a></span>(<span class='kw'>order</span> <span class='kw'>=</span> <span class='fu'><a href='https://www.rdocumentation.org/packages/base/topics/c'>c</a></span>(<span class='fl'>1</span>,<span class='fl'>0</span>,<span class='fl'>1</span>))),
                              <span class='kw'>notes</span> <span class='kw'>=</span> <span class='st'>"SARIMA(2,1,1)(1,0,1)"</span>),
                <span class='kw'>arima2</span> <span class='kw'>=</span> <span class='fu'><a href='https://www.rdocumentation.org/packages/base/topics/list'>list</a></span>(<span class='kw'>method</span> <span class='kw'>=</span> <span class='st'>"arima"</span>,
                              <span class='kw'>method_arg</span> <span class='kw'>=</span> <span class='fu'><a href='https://www.rdocumentation.org/packages/base/topics/list'>list</a></span>(<span class='kw'>order</span> <span class='kw'>=</span> <span class='fu'><a href='https://www.rdocumentation.org/packages/base/topics/c'>c</a></span>(<span class='fl'>2</span>,<span class='fl'>1</span>,<span class='fl'>2</span>),
                                                <span class='kw'>seasonal</span> <span class='kw'>=</span> <span class='fu'><a href='https://www.rdocumentation.org/packages/base/topics/list'>list</a></span>(<span class='kw'>order</span> <span class='kw'>=</span> <span class='fu'><a href='https://www.rdocumentation.org/packages/base/topics/c'>c</a></span>(<span class='fl'>1</span>,<span class='fl'>1</span>,<span class='fl'>1</span>))),
                              <span class='kw'>notes</span> <span class='kw'>=</span> <span class='st'>"SARIMA(2,1,2)(1,1,1)"</span>),
                <span class='kw'>auto_arima</span> <span class='kw'>=</span> <span class='fu'><a href='https://www.rdocumentation.org/packages/base/topics/list'>list</a></span>(<span class='kw'>method</span> <span class='kw'>=</span> <span class='st'>"auto.arima"</span>,
                                  <span class='kw'>method_arg</span> <span class='kw'>=</span> <span class='kw'>NULL</span>,
                                  <span class='kw'>notes</span> <span class='kw'>=</span> <span class='st'>"auto.arima model"</span>),
                <span class='kw'>hw</span> <span class='kw'>=</span> <span class='fu'><a href='https://www.rdocumentation.org/packages/base/topics/list'>list</a></span>(<span class='kw'>method</span> <span class='kw'>=</span> <span class='st'>"HoltWinters"</span>,
                          <span class='kw'>method_arg</span> <span class='kw'>=</span> <span class='kw'>NULL</span>,
                          <span class='kw'>notes</span> <span class='kw'>=</span> <span class='st'>"HoltWinters Model"</span>),
                <span class='kw'>tslm</span> <span class='kw'>=</span> <span class='fu'><a href='https://www.rdocumentation.org/packages/base/topics/list'>list</a></span>(<span class='kw'>method</span> <span class='kw'>=</span> <span class='st'>"tslm"</span>,
                            <span class='kw'>method_arg</span> <span class='kw'>=</span> <span class='fu'><a href='https://www.rdocumentation.org/packages/base/topics/list'>list</a></span>(<span class='kw'>formula</span> <span class='kw'>=</span> <span class='no'>input</span> ~ <span class='no'>trend</span> + <span class='no'>season</span>),
                            <span class='kw'>notes</span> <span class='kw'>=</span> <span class='st'>"tslm model with trend and seasonal components"</span>))

<span class='co'># Training the models with backtesting</span>
<span class='no'>md</span> <span class='kw'>&lt;-</span> <span class='fu'>train_model</span>(<span class='kw'>input</span> <span class='kw'>=</span> <span class='no'>USgas</span>,
                  <span class='kw'>methods</span> <span class='kw'>=</span> <span class='no'>methods</span>,
                  <span class='kw'>train_method</span> <span class='kw'>=</span> <span class='fu'><a href='https://www.rdocumentation.org/packages/base/topics/list'>list</a></span>(<span class='kw'>partitions</span> <span class='kw'>=</span> <span class='fl'>6</span>,
                                      <span class='kw'>sample.out</span> <span class='kw'>=</span> <span class='fl'>12</span>,
                                      <span class='kw'>space</span> <span class='kw'>=</span> <span class='fl'>3</span>),
                  <span class='kw'>horizon</span> <span class='kw'>=</span> <span class='fl'>12</span>,
                  <span class='kw'>error</span> <span class='kw'>=</span> <span class='st'>"MAPE"</span>)</div><div class='output co'>#&gt; <span class='warning'>Warning: NaNs produced</span></div><div class='output co'>#&gt; <span class='error'>Error in (function (x, order = c(0L, 0L, 0L), seasonal = list(order = c(0L,     0L, 0L), period = NA), xreg = NULL, include.mean = TRUE,     transform.pars = TRUE, fixed = NULL, init = NULL, method = c("CSS-ML",         "ML", "CSS"), n.cond, SSinit = c("Gardner1980", "Rossignol2011"),     optim.method = "BFGS", optim.control = list(), kappa = 1e+06) {    "%+%" &lt;- function(a, b) .Call(C_TSconv, a, b)    SSinit &lt;- match.arg(SSinit)    SS.G &lt;- SSinit == "Gardner1980"    upARIMA &lt;- function(mod, phi, theta) {        p &lt;- length(phi)        q &lt;- length(theta)        mod$phi &lt;- phi        mod$theta &lt;- theta        r &lt;- max(p, q + 1L)        if (p &gt; 0)             mod$T[1L:p, 1L] &lt;- phi        if (r &gt; 1L)             mod$Pn[1L:r, 1L:r] &lt;- if (SS.G)                 .Call(C_getQ0, phi, theta)            else .Call(C_getQ0bis, phi, theta, tol = 0)        else mod$Pn[1L, 1L] &lt;- if (p &gt; 0)             1/(1 - phi^2)        else 1        mod$a[] &lt;- 0        mod    }    arimaSS &lt;- function(y, mod) {        .Call(C_ARIMA_Like, y, mod, 0L, TRUE)    }    armafn &lt;- function(p, trans) {        par &lt;- coef        par[mask] &lt;- p        trarma &lt;- .Call(C_ARIMA_transPars, par, arma, trans)        if (is.null(Z &lt;- tryCatch(upARIMA(mod, trarma[[1L]],             trarma[[2L]]), error = function(e) NULL)))             return(.Machine$double.xmax)        if (ncxreg &gt; 0)             x &lt;- x - xreg %*% par[narma + (1L:ncxreg)]        res &lt;- .Call(C_ARIMA_Like, x, Z, 0L, FALSE)        s2 &lt;- res[1L]/res[3L]        0.5 * (log(s2) + res[2L]/res[3L])    }    armaCSS &lt;- function(p) {        par &lt;- as.double(fixed)        par[mask] &lt;- p        trarma &lt;- .Call(C_ARIMA_transPars, par, arma, FALSE)        if (ncxreg &gt; 0)             x &lt;- x - xreg %*% par[narma + (1L:ncxreg)]        res &lt;- .Call(C_ARIMA_CSS, x, arma, trarma[[1L]], trarma[[2L]],             as.integer(ncond), FALSE)        0.5 * log(res)    }    arCheck &lt;- function(ar) {        p &lt;- max(which(c(1, -ar) != 0)) - 1        if (!p)             return(TRUE)        all(Mod(polyroot(c(1, -ar[1L:p]))) &gt; 1)    }    maInvert &lt;- function(ma) {        q &lt;- length(ma)        q0 &lt;- max(which(c(1, ma) != 0)) - 1L        if (!q0)             return(ma)        roots &lt;- polyroot(c(1, ma[1L:q0]))        ind &lt;- Mod(roots) &lt; 1        if (all(!ind))             return(ma)        if (q0 == 1)             return(c(1/ma[1L], rep.int(0, q - q0)))        roots[ind] &lt;- 1/roots[ind]        x &lt;- 1        for (r in roots) x &lt;- c(x, 0) - c(0, x)/r        c(Re(x[-1L]), rep.int(0, q - q0))    }    series &lt;- deparse(substitute(x))    if (NCOL(x) &gt; 1L)         stop("only implemented for univariate time series")    method &lt;- match.arg(method)    x &lt;- as.ts(x)    if (!is.numeric(x))         stop("'x' must be numeric")    storage.mode(x) &lt;- "double"    dim(x) &lt;- NULL    n &lt;- length(x)    if (!missing(order))         if (!is.numeric(order) || length(order) != 3L || any(order &lt;             0))             stop("'order' must be a non-negative numeric vector of length 3")    if (!missing(seasonal))         if (is.list(seasonal)) {            if (is.null(seasonal$order))                 stop("'seasonal' must be a list with component 'order'")            if (!is.numeric(seasonal$order) || length(seasonal$order) !=                 3L || any(seasonal$order &lt; 0L))                 stop("'seasonal$order' must be a non-negative numeric vector of length 3")        }        else if (is.numeric(order)) {            if (length(order) == 3L)                 seasonal &lt;- list(order = seasonal)            else ("'seasonal' is of the wrong length")        }        else stop("'seasonal' must be a list with component 'order'")    if (is.null(seasonal$period) || is.na(seasonal$period) ||         seasonal$period == 0)         seasonal$period &lt;- frequency(x)    arma &lt;- as.integer(c(order[-2L], seasonal$order[-2L], seasonal$period,         order[2L], seasonal$order[2L]))    narma &lt;- sum(arma[1L:4L])    xtsp &lt;- tsp(x)    tsp(x) &lt;- NULL    Delta &lt;- 1    for (i in seq_len(order[2L])) Delta &lt;- Delta %+% c(1, -1)    for (i in seq_len(seasonal$order[2L])) Delta &lt;- Delta %+%         c(1, rep.int(0, seasonal$period - 1), -1)    Delta &lt;- -Delta[-1L]    nd &lt;- order[2L] + seasonal$order[2L]    n.used &lt;- sum(!is.na(x)) - length(Delta)    if (is.null(xreg)) {        ncxreg &lt;- 0L    }    else {        nmxreg &lt;- deparse(substitute(xreg))        if (NROW(xreg) != n)             stop("lengths of 'x' and 'xreg' do not match")        ncxreg &lt;- NCOL(xreg)        xreg &lt;- as.matrix(xreg)        storage.mode(xreg) &lt;- "double"    }    class(xreg) &lt;- NULL    if (ncxreg &gt; 0L &amp;&amp; is.null(colnames(xreg)))         colnames(xreg) &lt;- if (ncxreg == 1L)             nmxreg        else paste0(nmxreg, 1L:ncxreg)    if (include.mean &amp;&amp; (nd == 0L)) {        xreg &lt;- cbind(intercept = rep(1, n), xreg = xreg)        ncxreg &lt;- ncxreg + 1L    }    if (method == "CSS-ML") {        anyna &lt;- anyNA(x)        if (ncxreg)             anyna &lt;- anyna || anyNA(xreg)        if (anyna)             method &lt;- "ML"    }    if (method == "CSS" || method == "CSS-ML") {        ncond &lt;- order[2L] + seasonal$order[2L] * seasonal$period        ncond1 &lt;- order[1L] + seasonal$period * seasonal$order[1L]        ncond &lt;- ncond + if (!missing(n.cond))             max(n.cond, ncond1)        else ncond1    }    else ncond &lt;- 0    if (is.null(fixed))         fixed &lt;- rep(NA_real_, narma + ncxreg)    else if (length(fixed) != narma + ncxreg)         stop("wrong length for 'fixed'")    mask &lt;- is.na(fixed)    no.optim &lt;- !any(mask)    if (no.optim)         transform.pars &lt;- FALSE    if (transform.pars) {        ind &lt;- arma[1L] + arma[2L] + seq_len(arma[3L])        if (any(!mask[seq_len(arma[1L])]) || any(!mask[ind])) {            warning("some AR parameters were fixed: setting transform.pars = FALSE")            transform.pars &lt;- FALSE        }    }    init0 &lt;- rep.int(0, narma)    parscale &lt;- rep(1, narma)    if (ncxreg) {        cn &lt;- colnames(xreg)        orig.xreg &lt;- (ncxreg == 1L) || any(!mask[narma + 1L:ncxreg])        if (!orig.xreg) {            S &lt;- svd(na.omit(xreg))            xreg &lt;- xreg %*% S$v        }        dx &lt;- x        dxreg &lt;- xreg        if (order[2L] &gt; 0L) {            dx &lt;- diff(dx, 1L, order[2L])            dxreg &lt;- diff(dxreg, 1L, order[2L])        }        if (seasonal$period &gt; 1L &amp; seasonal$order[2L] &gt; 0) {            dx &lt;- diff(dx, seasonal$period, seasonal$order[2L])            dxreg &lt;- diff(dxreg, seasonal$period, seasonal$order[2L])        }        fit &lt;- if (length(dx) &gt; ncol(dxreg))             lm(dx ~ dxreg - 1, na.action = na.omit)        else list(rank = 0L)        if (fit$rank == 0L) {            fit &lt;- lm(x ~ xreg - 1, na.action = na.omit)        }        isna &lt;- is.na(x) | apply(xreg, 1L, anyNA)        n.used &lt;- sum(!isna) - length(Delta)        init0 &lt;- c(init0, coef(fit))        ses &lt;- summary(fit)$coefficients[, 2L]        parscale &lt;- c(parscale, 10 * ses)    }    if (n.used &lt;= 0)         stop("too few non-missing observations")    if (!is.null(init)) {        if (length(init) != length(init0))             stop("'init' is of the wrong length")        if (any(ind &lt;- is.na(init)))             init[ind] &lt;- init0[ind]        if (method == "ML") {            if (arma[1L] &gt; 0)                 if (!arCheck(init[1L:arma[1L]]))                   stop("non-stationary AR part")            if (arma[3L] &gt; 0)                 if (!arCheck(init[sum(arma[1L:2L]) + 1L:arma[3L]]))                   stop("non-stationary seasonal AR part")            if (transform.pars)                 init &lt;- .Call(C_ARIMA_Invtrans, as.double(init),                   arma)        }    }    else init &lt;- init0    coef &lt;- as.double(fixed)    if (!("parscale" %in% names(optim.control)))         optim.control$parscale &lt;- parscale[mask]    if (method == "CSS") {        res &lt;- if (no.optim)             list(convergence = 0L, par = numeric(), value = armaCSS(numeric()))        else optim(init[mask], armaCSS, method = optim.method,             hessian = TRUE, control = optim.control)        if (res$convergence &gt; 0)             warning(gettextf("possible convergence problem: optim gave code = %d",                 res$convergence), domain = NA)        coef[mask] &lt;- res$par        trarma &lt;- .Call(C_ARIMA_transPars, coef, arma, FALSE)        mod &lt;- makeARIMA(trarma[[1L]], trarma[[2L]], Delta, kappa,             SSinit)        if (ncxreg &gt; 0)             x &lt;- x - xreg %*% coef[narma + (1L:ncxreg)]        arimaSS(x, mod)        val &lt;- .Call(C_ARIMA_CSS, x, arma, trarma[[1L]], trarma[[2L]],             as.integer(ncond), TRUE)        sigma2 &lt;- val[[1L]]        var &lt;- if (no.optim)             numeric()        else solve(res$hessian * n.used)    }    else {        if (method == "CSS-ML") {            res &lt;- if (no.optim)                 list(convergence = 0L, par = numeric(), value = armaCSS(numeric()))            else optim(init[mask], armaCSS, method = optim.method,                 hessian = FALSE, control = optim.control)            if (res$convergence == 0)                 init[mask] &lt;- res$par            if (arma[1L] &gt; 0)                 if (!arCheck(init[1L:arma[1L]]))                   stop("non-stationary AR part from CSS")            if (arma[3L] &gt; 0)                 if (!arCheck(init[sum(arma[1L:2L]) + 1L:arma[3L]]))                   stop("non-stationary seasonal AR part from CSS")            ncond &lt;- 0L        }        if (transform.pars) {            init &lt;- .Call(C_ARIMA_Invtrans, init, arma)            if (arma[2L] &gt; 0) {                ind &lt;- arma[1L] + 1L:arma[2L]                init[ind] &lt;- maInvert(init[ind])            }            if (arma[4L] &gt; 0) {                ind &lt;- sum(arma[1L:3L]) + 1L:arma[4L]                init[ind] &lt;- maInvert(init[ind])            }        }        trarma &lt;- .Call(C_ARIMA_transPars, init, arma, transform.pars)        mod &lt;- makeARIMA(trarma[[1L]], trarma[[2L]], Delta, kappa,             SSinit)        res &lt;- if (no.optim)             list(convergence = 0, par = numeric(), value = armafn(numeric(),                 as.logical(transform.pars)))        else optim(init[mask], armafn, method = optim.method,             hessian = TRUE, control = optim.control, trans = as.logical(transform.pars))        if (res$convergence &gt; 0)             warning(gettextf("possible convergence problem: optim gave code = %d",                 res$convergence), domain = NA)        coef[mask] &lt;- res$par        if (transform.pars) {            if (arma[2L] &gt; 0L) {                ind &lt;- arma[1L] + 1L:arma[2L]                if (all(mask[ind]))                   coef[ind] &lt;- maInvert(coef[ind])            }            if (arma[4L] &gt; 0L) {                ind &lt;- sum(arma[1L:3L]) + 1L:arma[4L]                if (all(mask[ind]))                   coef[ind] &lt;- maInvert(coef[ind])            }            if (any(coef[mask] != res$par)) {                oldcode &lt;- res$convergence                res &lt;- optim(coef[mask], armafn, method = optim.method,                   hessian = TRUE, control = list(maxit = 0L,                     parscale = optim.control$parscale), trans = TRUE)                res$convergence &lt;- oldcode                coef[mask] &lt;- res$par            }            A &lt;- .Call(C_ARIMA_Gradtrans, as.double(coef), arma)            A &lt;- A[mask, mask]            var &lt;- crossprod(A, solve(res$hessian * n.used, A))            coef &lt;- .Call(C_ARIMA_undoPars, coef, arma)        }        else var &lt;- if (no.optim)             numeric()        else solve(res$hessian * n.used)        trarma &lt;- .Call(C_ARIMA_transPars, coef, arma, FALSE)        mod &lt;- makeARIMA(trarma[[1L]], trarma[[2L]], Delta, kappa,             SSinit)        val &lt;- if (ncxreg &gt; 0L)             arimaSS(x - xreg %*% coef[narma + (1L:ncxreg)], mod)        else arimaSS(x, mod)        sigma2 &lt;- val[[1L]][1L]/n.used    }    value &lt;- 2 * n.used * res$value + n.used + n.used * log(2 *         pi)    aic &lt;- if (method != "CSS")         value + 2 * sum(mask) + 2    else NA    nm &lt;- NULL    if (arma[1L] &gt; 0L)         nm &lt;- c(nm, paste0("ar", 1L:arma[1L]))    if (arma[2L] &gt; 0L)         nm &lt;- c(nm, paste0("ma", 1L:arma[2L]))    if (arma[3L] &gt; 0L)         nm &lt;- c(nm, paste0("sar", 1L:arma[3L]))    if (arma[4L] &gt; 0L)         nm &lt;- c(nm, paste0("sma", 1L:arma[4L]))    if (ncxreg &gt; 0L) {        nm &lt;- c(nm, cn)        if (!orig.xreg) {            ind &lt;- narma + 1L:ncxreg            coef[ind] &lt;- S$v %*% coef[ind]            A &lt;- diag(narma + ncxreg)            A[ind, ind] &lt;- S$v            A &lt;- A[mask, mask]            var &lt;- A %*% var %*% t(A)        }    }    names(coef) &lt;- nm    if (!no.optim)         dimnames(var) &lt;- list(nm[mask], nm[mask])    resid &lt;- val[[2L]]    tsp(resid) &lt;- xtsp    class(resid) &lt;- "ts"    structure(list(coef = coef, sigma2 = sigma2, var.coef = var,         mask = mask, loglik = -0.5 * value, aic = aic, arma = arma,         residuals = resid, call = match.call(), series = series,         code = res$convergence, n.cond = ncond, nobs = n.used,         model = mod), class = "Arima")})(structure(c(2510.5, 2330.7, 2050.6, 1783.3, 1632.9, 1513.1, 1525.6, 1653.1, 1475, 1567.8, 1908.5, 2587.5, 2677, 2309.5, 2246.6, 1807.2, 1522.4, 1444.4, 1598.1, 1669.2, 1494.1, 1649.1, 1701, 2120.2, 2487.6, 2242.4, 2258.4, 1881, 1611.5, 1591.4, 1748.4, 1725.7, 1542.2, 1645.9, 1913.6, 2378.9, 2700.5, 2500.3, 2197.9, 1743.5, 1514.7, 1368.4, 1600.5, 1651.6, 1428.6, 1553.2, 1753.6, 2263.7, 2675.8, 2511.1, 2100.9, 1745.2, 1573, 1483.7, 1584.9, 1578, 1482.2, 1557.2, 1782.8, 2327.7, 2561.9, 2243, 2205.8, 1724.9, 1522.6, 1534.1, 1686.6, 1695.1, 1422.5, 1428.2, 1663.4, 2326.4, 2165.3, 2144.4, 2126.4, 1681, 1526.3, 1550.9, 1758.7, 1751.7, 1462.1, 1644.2, 1765.4, 2122.8, 2475.6, 2567, 2128.8, 1810.1, 1559.1, 1555.2, 1659.9, 1896.1, 1590.5, 1627.8, 1834.5, 2399.2, 2734, 2503.4, 2278.2, 1823.9, 1576.4, 1604.2, 1708.6, 1682.9, 1460.9, 1635.8, 1868.9, 2399.7, 2729.7, 2332.5, 2170.7, 1741.3, 1504, 1527.8, 1658, 1736.5, 1575, 1666.5, 1776.2, 2491.9, 2809.8, 2481, 2142.9, 1691.8, 1617.3, 1649.5, 1825.8, 1878.9, 1637.5, 1664.9, 1973.3, 2714.1, 2888.6, 2452.4, 2230.5, 1825, 1667.4, 1657.3, 1890.5, 1891.8, 1655.6, 1744.5, 2031.9, 2541.9, 2756.2, 2500.7, 2127.8, 1953.1, 1873.8, 1868.4, 2069.8, 2008.8, 1807.2, 1901.1, 2167.8, 2503.9, 2878.8, 2567.2, 2521.1, 1967.5, 1752.5, 1742.9, 1926.3, 1927.4, 1767, 1866.8, 2316.9, 2920.8, 3204.1, 2741.2, 2557.9, 1961.7, 1810.2, 1745.4, 1881, 1933.1, 1809.3, 1912.8, 2357.5, 2679.2, 3115, 2925.2, 2591.3, 2007.9, 1858.1, 1899.9, 2067.7, 2052.7, 1901.3, 1987.3, 2249.1, 2588.2, 3091.7, 2652.3, 2356.3, 2083.8, 1965.8, 2000.7, 2186.6, 2208.4, 1947.8, 1925.2, 2159.4, 2866.3, 2900.9, 2329.1, 2529.3, 1927.9, 1896.9, 1912.1, 2132.7, 2104.9, 1922.6, 2036.9, 2351.3, 3065.8), .Tsp = c(2000, 2017.91666666667, 12), class = "ts"), order = c(2, 1, 1), seasonal = list(    order = c(1, 0, 1))): non-stationary seasonal AR part from CSS</span></div><div class='input'>
<span class='co'># View the model performance on the backtesting partitions</span>
<span class='no'>md</span>$<span class='no'>leaderboard</span></div><div class='output co'>#&gt; <span class='error'>Error in eval(expr, envir, enclos): object 'md' not found</span></div></pre>
  </div>
  <div class="col-md-3 hidden-xs hidden-sm" id="sidebar">
    <h2>Contents</h2>
    <ul class="nav nav-pills nav-stacked">
      <li><a href="#arguments">Arguments</a></li>
            
      <li><a href="#examples">Examples</a></li>
    </ul>

  </div>
</div>

      <footer>
      <div class="copyright">
  <p>Developed by Rami Krispin.</p>
</div>

<div class="pkgdown">
  <p>Site built with <a href="https://pkgdown.r-lib.org/">pkgdown</a> 1.3.0.</p>
</div>
      </footer>
   </div>

  

  </body>
</html>

